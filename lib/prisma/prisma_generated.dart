// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: non_constant_identifier_names

import 'package:orm/orm.dart';
import 'package:json_annotation/json_annotation.dart';
import 'dart:convert';

part 'prisma_generated.g.dart';

//******************************************************************************
// This file was generated by Prisma ORM
// GitHub: https://github.com/odroe/prisma
//******************************************************************************

class PrismaClient {

  late final Engine engine;

  PrismaClient(){
    engine = BinaryEngine(schema);
  }

late final user = UserModel(engine) ;
late final ad = AdModel(engine) ;
}

enum AdScalarFieldEnum implements PrismaEnum {
  id('id'),
  title('title'),
  filter('filter'),
  content('content'),
  createdAt('createdAt'),
  expiredAt('expiredAt'),
;
  @override
  final String value;
  const AdScalarFieldEnum(this.value);
}
enum JsonNullValueFilter implements PrismaEnum {
  dbNull('DbNull'),
  jsonNull('JsonNull'),
  anyNull('AnyNull'),
;
  @override
  final String value;
  const JsonNullValueFilter(this.value);
}
enum JsonNullValueInput implements PrismaEnum {
  jsonNull('JsonNull'),
;
  @override
  final String value;
  const JsonNullValueInput(this.value);
}
enum QueryMode implements PrismaEnum {
  default$('default'),
  insensitive('insensitive'),
;
  @override
  final String value;
  const QueryMode(this.value);
}
enum SortOrder implements PrismaEnum {
  asc('asc'),
  desc('desc'),
;
  @override
  final String value;
  const SortOrder(this.value);
}
enum TransactionIsolationLevel implements PrismaEnum {
  readUncommitted('ReadUncommitted'),
  readCommitted('ReadCommitted'),
  repeatableRead('RepeatableRead'),
  serializable('Serializable'),
;
  @override
  final String value;
  const TransactionIsolationLevel(this.value);
}
enum UserScalarFieldEnum implements PrismaEnum {
  id('id'),
  email('email'),
  name('name'),
  role('role'),
;
  @override
  final String value;
  const UserScalarFieldEnum(this.value);
}



class UserWhereInput implements ToField  {
  const UserWhereInput({
  this.aND,
  this.oR,
  this.nOT,
  this.id,
  this.email,
  this.name,
  this.role,
  });

  @JsonKey(name: 'AND' )
  final List<UserWhereInput>? aND;
  @JsonKey(name: 'OR' )
  final List<UserWhereInput>? oR;
  @JsonKey(name: 'NOT' )
  final List<UserWhereInput>? nOT;
  @JsonKey(name: 'id' )
  final IntFilter? id;
  @JsonKey(name: 'email' )
  final StringFilter? email;
  @JsonKey(name: 'name' )
  final StringFilter? name;
  @JsonKey(name: 'role' )
  final StringNullableListFilter? role;

@override
List<Field> toFields()=>[if(aND !=null)Field("AND",true,false,null,toObjectField(aND!),),if(oR !=null)Field("OR",true,false,null,toObjectField(oR!),),if(nOT !=null)Field("NOT",true,false,null,toObjectField(nOT!),),if(id !=null)Field("id",false,false,null,id!.toFields()
,),if(email !=null)Field("email",false,false,null,email!.toFields()
,),if(name !=null)Field("name",false,false,null,name!.toFields()
,),if(role !=null)Field("role",false,false,null,role!.toFields()
,),];
}
class UserOrderByWithRelationInput implements ToField  {
  const UserOrderByWithRelationInput({
  this.id,
  this.email,
  this.name,
  this.role,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'email' )
  final SortOrder? email;
  @JsonKey(name: 'name' )
  final SortOrder? name;
  @JsonKey(name: 'role' )
  final SortOrder? role;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),if(email !=null)Field("email",false,false,email!.value,null,),if(name !=null)Field("name",false,false,name!.value,null,),if(role !=null)Field("role",false,false,role!.value,null,),];
}
class UserWhereUniqueInput implements ToField  {
  const UserWhereUniqueInput({
  this.id,
  this.email,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'email' )
  final String? email;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!,null,),if(email !=null)Field("email",false,false,email!,null,),];
}
class UserOrderByWithAggregationInput implements ToField  {
  const UserOrderByWithAggregationInput({
  this.id,
  this.email,
  this.name,
  this.role,
  this.$count,
  this.$avg,
  this.$max,
  this.$min,
  this.$sum,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'email' )
  final SortOrder? email;
  @JsonKey(name: 'name' )
  final SortOrder? name;
  @JsonKey(name: 'role' )
  final SortOrder? role;
  @JsonKey(name: '_count' )
  final UserCountOrderByAggregateInput? $count;
  @JsonKey(name: '_avg' )
  final UserAvgOrderByAggregateInput? $avg;
  @JsonKey(name: '_max' )
  final UserMaxOrderByAggregateInput? $max;
  @JsonKey(name: '_min' )
  final UserMinOrderByAggregateInput? $min;
  @JsonKey(name: '_sum' )
  final UserSumOrderByAggregateInput? $sum;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),if(email !=null)Field("email",false,false,email!.value,null,),if(name !=null)Field("name",false,false,name!.value,null,),if(role !=null)Field("role",false,false,role!.value,null,),if($count !=null)Field("_count",false,false,null,$count!.toFields()
,),if($avg !=null)Field("_avg",false,false,null,$avg!.toFields()
,),if($max !=null)Field("_max",false,false,null,$max!.toFields()
,),if($min !=null)Field("_min",false,false,null,$min!.toFields()
,),if($sum !=null)Field("_sum",false,false,null,$sum!.toFields()
,),];
}
class UserScalarWhereWithAggregatesInput implements ToField  {
  const UserScalarWhereWithAggregatesInput({
  this.aND,
  this.oR,
  this.nOT,
  this.id,
  this.email,
  this.name,
  this.role,
  });

  @JsonKey(name: 'AND' )
  final List<UserScalarWhereWithAggregatesInput>? aND;
  @JsonKey(name: 'OR' )
  final List<UserScalarWhereWithAggregatesInput>? oR;
  @JsonKey(name: 'NOT' )
  final List<UserScalarWhereWithAggregatesInput>? nOT;
  @JsonKey(name: 'id' )
  final IntWithAggregatesFilter? id;
  @JsonKey(name: 'email' )
  final StringWithAggregatesFilter? email;
  @JsonKey(name: 'name' )
  final StringWithAggregatesFilter? name;
  @JsonKey(name: 'role' )
  final StringNullableListFilter? role;

@override
List<Field> toFields()=>[if(aND !=null)Field("AND",true,false,null,toObjectField(aND!),),if(oR !=null)Field("OR",true,false,null,toObjectField(oR!),),if(nOT !=null)Field("NOT",true,false,null,toObjectField(nOT!),),if(id !=null)Field("id",false,false,null,id!.toFields()
,),if(email !=null)Field("email",false,false,null,email!.toFields()
,),if(name !=null)Field("name",false,false,null,name!.toFields()
,),if(role !=null)Field("role",false,false,null,role!.toFields()
,),];
}
class AdWhereInput implements ToField  {
  const AdWhereInput({
  this.aND,
  this.oR,
  this.nOT,
  this.id,
  this.title,
  this.filter,
  this.content,
  this.createdAt,
  this.expiredAt,
  });

  @JsonKey(name: 'AND' )
  final List<AdWhereInput>? aND;
  @JsonKey(name: 'OR' )
  final List<AdWhereInput>? oR;
  @JsonKey(name: 'NOT' )
  final List<AdWhereInput>? nOT;
  @JsonKey(name: 'id' )
  final IntFilter? id;
  @JsonKey(name: 'title' )
  final StringFilter? title;
  @JsonKey(name: 'filter' )
  final JsonFilter? filter;
  @JsonKey(name: 'content' )
  final JsonFilter? content;
  @JsonKey(name: 'createdAt' )
  final DateTimeFilter? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTimeFilter? expiredAt;

@override
List<Field> toFields()=>[if(aND !=null)Field("AND",true,false,null,toObjectField(aND!),),if(oR !=null)Field("OR",true,false,null,toObjectField(oR!),),if(nOT !=null)Field("NOT",true,false,null,toObjectField(nOT!),),if(id !=null)Field("id",false,false,null,id!.toFields()
,),if(title !=null)Field("title",false,false,null,title!.toFields()
,),if(filter !=null)Field("filter",false,false,null,filter!.toFields()
,),if(content !=null)Field("content",false,false,null,content!.toFields()
,),if(createdAt !=null)Field("createdAt",false,false,null,createdAt!.toFields()
,),if(expiredAt !=null)Field("expiredAt",false,false,null,expiredAt!.toFields()
,),];
}
class AdOrderByWithRelationInput implements ToField  {
  const AdOrderByWithRelationInput({
  this.id,
  this.title,
  this.filter,
  this.content,
  this.createdAt,
  this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'title' )
  final SortOrder? title;
  @JsonKey(name: 'filter' )
  final SortOrder? filter;
  @JsonKey(name: 'content' )
  final SortOrder? content;
  @JsonKey(name: 'createdAt' )
  final SortOrder? createdAt;
  @JsonKey(name: 'expiredAt' )
  final SortOrder? expiredAt;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),if(title !=null)Field("title",false,false,title!.value,null,),if(filter !=null)Field("filter",false,false,filter!.value,null,),if(content !=null)Field("content",false,false,content!.value,null,),if(createdAt !=null)Field("createdAt",false,false,createdAt!.value,null,),if(expiredAt !=null)Field("expiredAt",false,false,expiredAt!.value,null,),];
}
class AdWhereUniqueInput implements ToField  {
  const AdWhereUniqueInput({
  this.id,
  });

  @JsonKey(name: 'id' )
  final int? id;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!,null,),];
}
class AdOrderByWithAggregationInput implements ToField  {
  const AdOrderByWithAggregationInput({
  this.id,
  this.title,
  this.filter,
  this.content,
  this.createdAt,
  this.expiredAt,
  this.$count,
  this.$avg,
  this.$max,
  this.$min,
  this.$sum,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'title' )
  final SortOrder? title;
  @JsonKey(name: 'filter' )
  final SortOrder? filter;
  @JsonKey(name: 'content' )
  final SortOrder? content;
  @JsonKey(name: 'createdAt' )
  final SortOrder? createdAt;
  @JsonKey(name: 'expiredAt' )
  final SortOrder? expiredAt;
  @JsonKey(name: '_count' )
  final AdCountOrderByAggregateInput? $count;
  @JsonKey(name: '_avg' )
  final AdAvgOrderByAggregateInput? $avg;
  @JsonKey(name: '_max' )
  final AdMaxOrderByAggregateInput? $max;
  @JsonKey(name: '_min' )
  final AdMinOrderByAggregateInput? $min;
  @JsonKey(name: '_sum' )
  final AdSumOrderByAggregateInput? $sum;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),if(title !=null)Field("title",false,false,title!.value,null,),if(filter !=null)Field("filter",false,false,filter!.value,null,),if(content !=null)Field("content",false,false,content!.value,null,),if(createdAt !=null)Field("createdAt",false,false,createdAt!.value,null,),if(expiredAt !=null)Field("expiredAt",false,false,expiredAt!.value,null,),if($count !=null)Field("_count",false,false,null,$count!.toFields()
,),if($avg !=null)Field("_avg",false,false,null,$avg!.toFields()
,),if($max !=null)Field("_max",false,false,null,$max!.toFields()
,),if($min !=null)Field("_min",false,false,null,$min!.toFields()
,),if($sum !=null)Field("_sum",false,false,null,$sum!.toFields()
,),];
}
class AdScalarWhereWithAggregatesInput implements ToField  {
  const AdScalarWhereWithAggregatesInput({
  this.aND,
  this.oR,
  this.nOT,
  this.id,
  this.title,
  this.filter,
  this.content,
  this.createdAt,
  this.expiredAt,
  });

  @JsonKey(name: 'AND' )
  final List<AdScalarWhereWithAggregatesInput>? aND;
  @JsonKey(name: 'OR' )
  final List<AdScalarWhereWithAggregatesInput>? oR;
  @JsonKey(name: 'NOT' )
  final List<AdScalarWhereWithAggregatesInput>? nOT;
  @JsonKey(name: 'id' )
  final IntWithAggregatesFilter? id;
  @JsonKey(name: 'title' )
  final StringWithAggregatesFilter? title;
  @JsonKey(name: 'filter' )
  final JsonWithAggregatesFilter? filter;
  @JsonKey(name: 'content' )
  final JsonWithAggregatesFilter? content;
  @JsonKey(name: 'createdAt' )
  final DateTimeWithAggregatesFilter? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTimeWithAggregatesFilter? expiredAt;

@override
List<Field> toFields()=>[if(aND !=null)Field("AND",true,false,null,toObjectField(aND!),),if(oR !=null)Field("OR",true,false,null,toObjectField(oR!),),if(nOT !=null)Field("NOT",true,false,null,toObjectField(nOT!),),if(id !=null)Field("id",false,false,null,id!.toFields()
,),if(title !=null)Field("title",false,false,null,title!.toFields()
,),if(filter !=null)Field("filter",false,false,null,filter!.toFields()
,),if(content !=null)Field("content",false,false,null,content!.toFields()
,),if(createdAt !=null)Field("createdAt",false,false,null,createdAt!.toFields()
,),if(expiredAt !=null)Field("expiredAt",false,false,null,expiredAt!.toFields()
,),];
}
class UserCreateInput implements ToField  {
  const UserCreateInput({
 required this.email,
 required this.name,
  this.role,
  });

  @JsonKey(name: 'email' )
  final String email;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'role' )
  final List<UserCreateroleInput>? role;

@override
List<Field> toFields()=>[Field("email",false,false,email,null,),Field("name",false,false,name,null,),if(role !=null)Field("role",true,false,null,toObjectField(role!),),];
}
class UserUncheckedCreateInput implements ToField  {
  const UserUncheckedCreateInput({
  this.id,
 required this.email,
 required this.name,
  this.role,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'email' )
  final String email;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'role' )
  final List<UserCreateroleInput>? role;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!,null,),Field("email",false,false,email,null,),Field("name",false,false,name,null,),if(role !=null)Field("role",true,false,null,toObjectField(role!),),];
}
class UserUpdateInput implements ToField  {
  const UserUpdateInput({
  this.email,
  this.name,
  this.role,
  });

  @JsonKey(name: 'email' )
  final StringFieldUpdateOperationsInput? email;
  @JsonKey(name: 'name' )
  final StringFieldUpdateOperationsInput? name;
  @JsonKey(name: 'role' )
  final List<UserUpdateroleInput>? role;

@override
List<Field> toFields()=>[if(email !=null)Field("email",false,false,null,email!.toFields()
,),if(name !=null)Field("name",false,false,null,name!.toFields()
,),if(role !=null)Field("role",true,false,null,toObjectField(role!),),];
}
class UserUncheckedUpdateInput implements ToField  {
  const UserUncheckedUpdateInput({
  this.id,
  this.email,
  this.name,
  this.role,
  });

  @JsonKey(name: 'id' )
  final IntFieldUpdateOperationsInput? id;
  @JsonKey(name: 'email' )
  final StringFieldUpdateOperationsInput? email;
  @JsonKey(name: 'name' )
  final StringFieldUpdateOperationsInput? name;
  @JsonKey(name: 'role' )
  final List<UserUpdateroleInput>? role;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,null,id!.toFields()
,),if(email !=null)Field("email",false,false,null,email!.toFields()
,),if(name !=null)Field("name",false,false,null,name!.toFields()
,),if(role !=null)Field("role",true,false,null,toObjectField(role!),),];
}
class UserCreateManyInput implements ToField  {
  const UserCreateManyInput({
  this.id,
 required this.email,
 required this.name,
  this.role,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'email' )
  final String email;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'role' )
  final List<UserCreateroleInput>? role;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!,null,),Field("email",false,false,email,null,),Field("name",false,false,name,null,),if(role !=null)Field("role",true,false,null,toObjectField(role!),),];
}
class UserUpdateManyMutationInput implements ToField  {
  const UserUpdateManyMutationInput({
  this.email,
  this.name,
  this.role,
  });

  @JsonKey(name: 'email' )
  final StringFieldUpdateOperationsInput? email;
  @JsonKey(name: 'name' )
  final StringFieldUpdateOperationsInput? name;
  @JsonKey(name: 'role' )
  final List<UserUpdateroleInput>? role;

@override
List<Field> toFields()=>[if(email !=null)Field("email",false,false,null,email!.toFields()
,),if(name !=null)Field("name",false,false,null,name!.toFields()
,),if(role !=null)Field("role",true,false,null,toObjectField(role!),),];
}
class UserUncheckedUpdateManyInput implements ToField  {
  const UserUncheckedUpdateManyInput({
  this.id,
  this.email,
  this.name,
  this.role,
  });

  @JsonKey(name: 'id' )
  final IntFieldUpdateOperationsInput? id;
  @JsonKey(name: 'email' )
  final StringFieldUpdateOperationsInput? email;
  @JsonKey(name: 'name' )
  final StringFieldUpdateOperationsInput? name;
  @JsonKey(name: 'role' )
  final List<UserUpdateroleInput>? role;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,null,id!.toFields()
,),if(email !=null)Field("email",false,false,null,email!.toFields()
,),if(name !=null)Field("name",false,false,null,name!.toFields()
,),if(role !=null)Field("role",true,false,null,toObjectField(role!),),];
}
class AdCreateInput implements ToField  {
  const AdCreateInput({
 required this.title,
 required this.filter,
 required this.content,
  this.createdAt,
 required this.expiredAt,
  });

  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'filter' )
  final Map<String,dynamic> filter;
  @JsonKey(name: 'content' )
  final Map<String,dynamic> content;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTime expiredAt;

@override
List<Field> toFields()=>[Field("title",false,false,title,null,),Field("filter",false,false,filter,null,),Field("content",false,false,content,null,),if(createdAt !=null)Field("createdAt",false,false,createdAt!,null,),Field("expiredAt",false,false,expiredAt,null,),];
}
class AdUncheckedCreateInput implements ToField  {
  const AdUncheckedCreateInput({
  this.id,
 required this.title,
 required this.filter,
 required this.content,
  this.createdAt,
 required this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'filter' )
  final Map<String,dynamic> filter;
  @JsonKey(name: 'content' )
  final Map<String,dynamic> content;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTime expiredAt;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!,null,),Field("title",false,false,title,null,),Field("filter",false,false,filter,null,),Field("content",false,false,content,null,),if(createdAt !=null)Field("createdAt",false,false,createdAt!,null,),Field("expiredAt",false,false,expiredAt,null,),];
}
class AdUpdateInput implements ToField  {
  const AdUpdateInput({
  this.title,
  this.filter,
  this.content,
  this.createdAt,
  this.expiredAt,
  });

  @JsonKey(name: 'title' )
  final StringFieldUpdateOperationsInput? title;
  @JsonKey(name: 'filter' )
  final Map<String,dynamic>? filter;
  @JsonKey(name: 'content' )
  final Map<String,dynamic>? content;
  @JsonKey(name: 'createdAt' )
  final DateTimeFieldUpdateOperationsInput? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTimeFieldUpdateOperationsInput? expiredAt;

@override
List<Field> toFields()=>[if(title !=null)Field("title",false,false,null,title!.toFields()
,),if(filter !=null)Field("filter",false,false,filter!,null,),if(content !=null)Field("content",false,false,content!,null,),if(createdAt !=null)Field("createdAt",false,false,null,createdAt!.toFields()
,),if(expiredAt !=null)Field("expiredAt",false,false,null,expiredAt!.toFields()
,),];
}
class AdUncheckedUpdateInput implements ToField  {
  const AdUncheckedUpdateInput({
  this.id,
  this.title,
  this.filter,
  this.content,
  this.createdAt,
  this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final IntFieldUpdateOperationsInput? id;
  @JsonKey(name: 'title' )
  final StringFieldUpdateOperationsInput? title;
  @JsonKey(name: 'filter' )
  final Map<String,dynamic>? filter;
  @JsonKey(name: 'content' )
  final Map<String,dynamic>? content;
  @JsonKey(name: 'createdAt' )
  final DateTimeFieldUpdateOperationsInput? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTimeFieldUpdateOperationsInput? expiredAt;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,null,id!.toFields()
,),if(title !=null)Field("title",false,false,null,title!.toFields()
,),if(filter !=null)Field("filter",false,false,filter!,null,),if(content !=null)Field("content",false,false,content!,null,),if(createdAt !=null)Field("createdAt",false,false,null,createdAt!.toFields()
,),if(expiredAt !=null)Field("expiredAt",false,false,null,expiredAt!.toFields()
,),];
}
class AdCreateManyInput implements ToField  {
  const AdCreateManyInput({
  this.id,
 required this.title,
 required this.filter,
 required this.content,
  this.createdAt,
 required this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'filter' )
  final Map<String,dynamic> filter;
  @JsonKey(name: 'content' )
  final Map<String,dynamic> content;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTime expiredAt;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!,null,),Field("title",false,false,title,null,),Field("filter",false,false,filter,null,),Field("content",false,false,content,null,),if(createdAt !=null)Field("createdAt",false,false,createdAt!,null,),Field("expiredAt",false,false,expiredAt,null,),];
}
class AdUpdateManyMutationInput implements ToField  {
  const AdUpdateManyMutationInput({
  this.title,
  this.filter,
  this.content,
  this.createdAt,
  this.expiredAt,
  });

  @JsonKey(name: 'title' )
  final StringFieldUpdateOperationsInput? title;
  @JsonKey(name: 'filter' )
  final Map<String,dynamic>? filter;
  @JsonKey(name: 'content' )
  final Map<String,dynamic>? content;
  @JsonKey(name: 'createdAt' )
  final DateTimeFieldUpdateOperationsInput? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTimeFieldUpdateOperationsInput? expiredAt;

@override
List<Field> toFields()=>[if(title !=null)Field("title",false,false,null,title!.toFields()
,),if(filter !=null)Field("filter",false,false,filter!,null,),if(content !=null)Field("content",false,false,content!,null,),if(createdAt !=null)Field("createdAt",false,false,null,createdAt!.toFields()
,),if(expiredAt !=null)Field("expiredAt",false,false,null,expiredAt!.toFields()
,),];
}
class AdUncheckedUpdateManyInput implements ToField  {
  const AdUncheckedUpdateManyInput({
  this.id,
  this.title,
  this.filter,
  this.content,
  this.createdAt,
  this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final IntFieldUpdateOperationsInput? id;
  @JsonKey(name: 'title' )
  final StringFieldUpdateOperationsInput? title;
  @JsonKey(name: 'filter' )
  final Map<String,dynamic>? filter;
  @JsonKey(name: 'content' )
  final Map<String,dynamic>? content;
  @JsonKey(name: 'createdAt' )
  final DateTimeFieldUpdateOperationsInput? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTimeFieldUpdateOperationsInput? expiredAt;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,null,id!.toFields()
,),if(title !=null)Field("title",false,false,null,title!.toFields()
,),if(filter !=null)Field("filter",false,false,filter!,null,),if(content !=null)Field("content",false,false,content!,null,),if(createdAt !=null)Field("createdAt",false,false,null,createdAt!.toFields()
,),if(expiredAt !=null)Field("expiredAt",false,false,null,expiredAt!.toFields()
,),];
}
class IntFilter implements ToField  {
  const IntFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final NestedIntFilter? not;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),];
}
class StringFilter implements ToField  {
  const StringFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.mode,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'mode' )
  final QueryMode? mode;
  @JsonKey(name: 'not' )
  final NestedStringFilter? not;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(contains !=null)Field("contains",false,false,contains!,null,),if(startsWith !=null)Field("startsWith",false,false,startsWith!,null,),if(endsWith !=null)Field("endsWith",false,false,endsWith!,null,),if(mode !=null)Field("mode",false,false,mode!.value,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),];
}
class StringNullableListFilter implements ToField  {
  const StringNullableListFilter({
  this.equals,
  this.has,
  this.hasEvery,
  this.hasSome,
  this.isEmpty,
  });

  @JsonKey(name: 'equals' )
  final List<String>? equals;
  @JsonKey(name: 'has' )
  final String? has;
  @JsonKey(name: 'hasEvery' )
  final List<String>? hasEvery;
  @JsonKey(name: 'hasSome' )
  final List<String>? hasSome;
  @JsonKey(name: 'isEmpty' )
  final bool? isEmpty;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",true,false,toScalerField(equals!),null,),if(has !=null)Field("has",false,false,has!,null,),if(hasEvery !=null)Field("hasEvery",true,false,toScalerField(hasEvery!),null,),if(hasSome !=null)Field("hasSome",true,false,toScalerField(hasSome!),null,),if(isEmpty !=null)Field("isEmpty",false,false,isEmpty!,null,),];
}
class UserCountOrderByAggregateInput implements ToField  {
  const UserCountOrderByAggregateInput({
  this.id,
  this.email,
  this.name,
  this.role,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'email' )
  final SortOrder? email;
  @JsonKey(name: 'name' )
  final SortOrder? name;
  @JsonKey(name: 'role' )
  final SortOrder? role;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),if(email !=null)Field("email",false,false,email!.value,null,),if(name !=null)Field("name",false,false,name!.value,null,),if(role !=null)Field("role",false,false,role!.value,null,),];
}
class UserAvgOrderByAggregateInput implements ToField  {
  const UserAvgOrderByAggregateInput({
  this.id,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),];
}
class UserMaxOrderByAggregateInput implements ToField  {
  const UserMaxOrderByAggregateInput({
  this.id,
  this.email,
  this.name,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'email' )
  final SortOrder? email;
  @JsonKey(name: 'name' )
  final SortOrder? name;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),if(email !=null)Field("email",false,false,email!.value,null,),if(name !=null)Field("name",false,false,name!.value,null,),];
}
class UserMinOrderByAggregateInput implements ToField  {
  const UserMinOrderByAggregateInput({
  this.id,
  this.email,
  this.name,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'email' )
  final SortOrder? email;
  @JsonKey(name: 'name' )
  final SortOrder? name;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),if(email !=null)Field("email",false,false,email!.value,null,),if(name !=null)Field("name",false,false,name!.value,null,),];
}
class UserSumOrderByAggregateInput implements ToField  {
  const UserSumOrderByAggregateInput({
  this.id,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),];
}
class IntWithAggregatesFilter implements ToField  {
  const IntWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$avg,
  this.$sum,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final NestedIntWithAggregatesFilter? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_avg' )
  final NestedFloatFilter? $avg;
  @JsonKey(name: '_sum' )
  final NestedIntFilter? $sum;
  @JsonKey(name: '_min' )
  final NestedIntFilter? $min;
  @JsonKey(name: '_max' )
  final NestedIntFilter? $max;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),if($count !=null)Field("_count",false,false,null,$count!.toFields()
,),if($avg !=null)Field("_avg",false,false,null,$avg!.toFields()
,),if($sum !=null)Field("_sum",false,false,null,$sum!.toFields()
,),if($min !=null)Field("_min",false,false,null,$min!.toFields()
,),if($max !=null)Field("_max",false,false,null,$max!.toFields()
,),];
}
class StringWithAggregatesFilter implements ToField  {
  const StringWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.mode,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'mode' )
  final QueryMode? mode;
  @JsonKey(name: 'not' )
  final NestedStringWithAggregatesFilter? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedStringFilter? $min;
  @JsonKey(name: '_max' )
  final NestedStringFilter? $max;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(contains !=null)Field("contains",false,false,contains!,null,),if(startsWith !=null)Field("startsWith",false,false,startsWith!,null,),if(endsWith !=null)Field("endsWith",false,false,endsWith!,null,),if(mode !=null)Field("mode",false,false,mode!.value,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),if($count !=null)Field("_count",false,false,null,$count!.toFields()
,),if($min !=null)Field("_min",false,false,null,$min!.toFields()
,),if($max !=null)Field("_max",false,false,null,$max!.toFields()
,),];
}
class JsonFilter implements ToField  {
  const JsonFilter({
  this.equals,
  this.path,
  this.string_contains,
  this.string_starts_with,
  this.string_ends_with,
  this.array_contains,
  this.array_starts_with,
  this.array_ends_with,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final Map<String,dynamic>? equals;
  @JsonKey(name: 'path' )
  final List<String>? path;
  @JsonKey(name: 'string_contains' )
  final String? string_contains;
  @JsonKey(name: 'string_starts_with' )
  final String? string_starts_with;
  @JsonKey(name: 'string_ends_with' )
  final String? string_ends_with;
  @JsonKey(name: 'array_contains' )
  final Map<String,dynamic>? array_contains;
  @JsonKey(name: 'array_starts_with' )
  final Map<String,dynamic>? array_starts_with;
  @JsonKey(name: 'array_ends_with' )
  final Map<String,dynamic>? array_ends_with;
  @JsonKey(name: 'lt' )
  final Map<String,dynamic>? lt;
  @JsonKey(name: 'lte' )
  final Map<String,dynamic>? lte;
  @JsonKey(name: 'gt' )
  final Map<String,dynamic>? gt;
  @JsonKey(name: 'gte' )
  final Map<String,dynamic>? gte;
  @JsonKey(name: 'not' )
  final Map<String,dynamic>? not;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(path !=null)Field("path",true,false,toScalerField(path!),null,),if(string_contains !=null)Field("string_contains",false,false,string_contains!,null,),if(string_starts_with !=null)Field("string_starts_with",false,false,string_starts_with!,null,),if(string_ends_with !=null)Field("string_ends_with",false,false,string_ends_with!,null,),if(array_contains !=null)Field("array_contains",false,false,array_contains!,null,),if(array_starts_with !=null)Field("array_starts_with",false,false,array_starts_with!,null,),if(array_ends_with !=null)Field("array_ends_with",false,false,array_ends_with!,null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,not!,null,),];
}
class DateTimeFilter implements ToField  {
  const DateTimeFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final DateTime? equals;
  @JsonKey(name: 'in' )
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn' )
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt' )
  final DateTime? lt;
  @JsonKey(name: 'lte' )
  final DateTime? lte;
  @JsonKey(name: 'gt' )
  final DateTime? gt;
  @JsonKey(name: 'gte' )
  final DateTime? gte;
  @JsonKey(name: 'not' )
  final NestedDateTimeFilter? not;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),];
}
class AdCountOrderByAggregateInput implements ToField  {
  const AdCountOrderByAggregateInput({
  this.id,
  this.title,
  this.filter,
  this.content,
  this.createdAt,
  this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'title' )
  final SortOrder? title;
  @JsonKey(name: 'filter' )
  final SortOrder? filter;
  @JsonKey(name: 'content' )
  final SortOrder? content;
  @JsonKey(name: 'createdAt' )
  final SortOrder? createdAt;
  @JsonKey(name: 'expiredAt' )
  final SortOrder? expiredAt;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),if(title !=null)Field("title",false,false,title!.value,null,),if(filter !=null)Field("filter",false,false,filter!.value,null,),if(content !=null)Field("content",false,false,content!.value,null,),if(createdAt !=null)Field("createdAt",false,false,createdAt!.value,null,),if(expiredAt !=null)Field("expiredAt",false,false,expiredAt!.value,null,),];
}
class AdAvgOrderByAggregateInput implements ToField  {
  const AdAvgOrderByAggregateInput({
  this.id,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),];
}
class AdMaxOrderByAggregateInput implements ToField  {
  const AdMaxOrderByAggregateInput({
  this.id,
  this.title,
  this.createdAt,
  this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'title' )
  final SortOrder? title;
  @JsonKey(name: 'createdAt' )
  final SortOrder? createdAt;
  @JsonKey(name: 'expiredAt' )
  final SortOrder? expiredAt;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),if(title !=null)Field("title",false,false,title!.value,null,),if(createdAt !=null)Field("createdAt",false,false,createdAt!.value,null,),if(expiredAt !=null)Field("expiredAt",false,false,expiredAt!.value,null,),];
}
class AdMinOrderByAggregateInput implements ToField  {
  const AdMinOrderByAggregateInput({
  this.id,
  this.title,
  this.createdAt,
  this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'title' )
  final SortOrder? title;
  @JsonKey(name: 'createdAt' )
  final SortOrder? createdAt;
  @JsonKey(name: 'expiredAt' )
  final SortOrder? expiredAt;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),if(title !=null)Field("title",false,false,title!.value,null,),if(createdAt !=null)Field("createdAt",false,false,createdAt!.value,null,),if(expiredAt !=null)Field("expiredAt",false,false,expiredAt!.value,null,),];
}
class AdSumOrderByAggregateInput implements ToField  {
  const AdSumOrderByAggregateInput({
  this.id,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;

@override
List<Field> toFields()=>[if(id !=null)Field("id",false,false,id!.value,null,),];
}
class JsonWithAggregatesFilter implements ToField  {
  const JsonWithAggregatesFilter({
  this.equals,
  this.path,
  this.string_contains,
  this.string_starts_with,
  this.string_ends_with,
  this.array_contains,
  this.array_starts_with,
  this.array_ends_with,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final Map<String,dynamic>? equals;
  @JsonKey(name: 'path' )
  final List<String>? path;
  @JsonKey(name: 'string_contains' )
  final String? string_contains;
  @JsonKey(name: 'string_starts_with' )
  final String? string_starts_with;
  @JsonKey(name: 'string_ends_with' )
  final String? string_ends_with;
  @JsonKey(name: 'array_contains' )
  final Map<String,dynamic>? array_contains;
  @JsonKey(name: 'array_starts_with' )
  final Map<String,dynamic>? array_starts_with;
  @JsonKey(name: 'array_ends_with' )
  final Map<String,dynamic>? array_ends_with;
  @JsonKey(name: 'lt' )
  final Map<String,dynamic>? lt;
  @JsonKey(name: 'lte' )
  final Map<String,dynamic>? lte;
  @JsonKey(name: 'gt' )
  final Map<String,dynamic>? gt;
  @JsonKey(name: 'gte' )
  final Map<String,dynamic>? gte;
  @JsonKey(name: 'not' )
  final Map<String,dynamic>? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedJsonFilter? $min;
  @JsonKey(name: '_max' )
  final NestedJsonFilter? $max;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(path !=null)Field("path",true,false,toScalerField(path!),null,),if(string_contains !=null)Field("string_contains",false,false,string_contains!,null,),if(string_starts_with !=null)Field("string_starts_with",false,false,string_starts_with!,null,),if(string_ends_with !=null)Field("string_ends_with",false,false,string_ends_with!,null,),if(array_contains !=null)Field("array_contains",false,false,array_contains!,null,),if(array_starts_with !=null)Field("array_starts_with",false,false,array_starts_with!,null,),if(array_ends_with !=null)Field("array_ends_with",false,false,array_ends_with!,null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,not!,null,),if($count !=null)Field("_count",false,false,null,$count!.toFields()
,),if($min !=null)Field("_min",false,false,null,$min!.toFields()
,),if($max !=null)Field("_max",false,false,null,$max!.toFields()
,),];
}
class DateTimeWithAggregatesFilter implements ToField  {
  const DateTimeWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final DateTime? equals;
  @JsonKey(name: 'in' )
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn' )
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt' )
  final DateTime? lt;
  @JsonKey(name: 'lte' )
  final DateTime? lte;
  @JsonKey(name: 'gt' )
  final DateTime? gt;
  @JsonKey(name: 'gte' )
  final DateTime? gte;
  @JsonKey(name: 'not' )
  final NestedDateTimeWithAggregatesFilter? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedDateTimeFilter? $min;
  @JsonKey(name: '_max' )
  final NestedDateTimeFilter? $max;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),if($count !=null)Field("_count",false,false,null,$count!.toFields()
,),if($min !=null)Field("_min",false,false,null,$min!.toFields()
,),if($max !=null)Field("_max",false,false,null,$max!.toFields()
,),];
}
class UserCreateroleInput implements ToField  {
  const UserCreateroleInput({
 required this.set$,
  });

  @JsonKey(name: 'set' )
  final List<String> set$;

@override
List<Field> toFields()=>[Field("set",true,false,toScalerField(set$),null,),];
}
class StringFieldUpdateOperationsInput implements ToField  {
  const StringFieldUpdateOperationsInput({
  this.set$,
  });

  @JsonKey(name: 'set' )
  final String? set$;

@override
List<Field> toFields()=>[if(set$ !=null)Field("set",false,false,set$!,null,),];
}
class UserUpdateroleInput implements ToField  {
  const UserUpdateroleInput({
  this.set$,
  this.push,
  });

  @JsonKey(name: 'set' )
  final List<String>? set$;
  @JsonKey(name: 'push' )
  final List<String>? push;

@override
List<Field> toFields()=>[if(set$ !=null)Field("set",true,false,toScalerField(set$!),null,),if(push !=null)Field("push",true,false,toScalerField(push!),null,),];
}
class IntFieldUpdateOperationsInput implements ToField  {
  const IntFieldUpdateOperationsInput({
  this.set$,
  this.increment,
  this.decrement,
  this.multiply,
  this.divide,
  });

  @JsonKey(name: 'set' )
  final int? set$;
  @JsonKey(name: 'increment' )
  final int? increment;
  @JsonKey(name: 'decrement' )
  final int? decrement;
  @JsonKey(name: 'multiply' )
  final int? multiply;
  @JsonKey(name: 'divide' )
  final int? divide;

@override
List<Field> toFields()=>[if(set$ !=null)Field("set",false,false,set$!,null,),if(increment !=null)Field("increment",false,false,increment!,null,),if(decrement !=null)Field("decrement",false,false,decrement!,null,),if(multiply !=null)Field("multiply",false,false,multiply!,null,),if(divide !=null)Field("divide",false,false,divide!,null,),];
}
class DateTimeFieldUpdateOperationsInput implements ToField  {
  const DateTimeFieldUpdateOperationsInput({
  this.set$,
  });

  @JsonKey(name: 'set' )
  final DateTime? set$;

@override
List<Field> toFields()=>[if(set$ !=null)Field("set",false,false,set$!,null,),];
}
class NestedIntFilter implements ToField  {
  const NestedIntFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final NestedIntFilter? not;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),];
}
class NestedStringFilter implements ToField  {
  const NestedStringFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'not' )
  final NestedStringFilter? not;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(contains !=null)Field("contains",false,false,contains!,null,),if(startsWith !=null)Field("startsWith",false,false,startsWith!,null,),if(endsWith !=null)Field("endsWith",false,false,endsWith!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),];
}
class NestedIntWithAggregatesFilter implements ToField  {
  const NestedIntWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$avg,
  this.$sum,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final NestedIntWithAggregatesFilter? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_avg' )
  final NestedFloatFilter? $avg;
  @JsonKey(name: '_sum' )
  final NestedIntFilter? $sum;
  @JsonKey(name: '_min' )
  final NestedIntFilter? $min;
  @JsonKey(name: '_max' )
  final NestedIntFilter? $max;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),if($count !=null)Field("_count",false,false,null,$count!.toFields()
,),if($avg !=null)Field("_avg",false,false,null,$avg!.toFields()
,),if($sum !=null)Field("_sum",false,false,null,$sum!.toFields()
,),if($min !=null)Field("_min",false,false,null,$min!.toFields()
,),if($max !=null)Field("_max",false,false,null,$max!.toFields()
,),];
}
class NestedFloatFilter implements ToField  {
  const NestedFloatFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final double? equals;
  @JsonKey(name: 'in' )
  final List<double>? in$;
  @JsonKey(name: 'notIn' )
  final List<double>? notIn;
  @JsonKey(name: 'lt' )
  final double? lt;
  @JsonKey(name: 'lte' )
  final double? lte;
  @JsonKey(name: 'gt' )
  final double? gt;
  @JsonKey(name: 'gte' )
  final double? gte;
  @JsonKey(name: 'not' )
  final NestedFloatFilter? not;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),];
}
class NestedStringWithAggregatesFilter implements ToField  {
  const NestedStringWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'not' )
  final NestedStringWithAggregatesFilter? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedStringFilter? $min;
  @JsonKey(name: '_max' )
  final NestedStringFilter? $max;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(contains !=null)Field("contains",false,false,contains!,null,),if(startsWith !=null)Field("startsWith",false,false,startsWith!,null,),if(endsWith !=null)Field("endsWith",false,false,endsWith!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),if($count !=null)Field("_count",false,false,null,$count!.toFields()
,),if($min !=null)Field("_min",false,false,null,$min!.toFields()
,),if($max !=null)Field("_max",false,false,null,$max!.toFields()
,),];
}
class NestedDateTimeFilter implements ToField  {
  const NestedDateTimeFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final DateTime? equals;
  @JsonKey(name: 'in' )
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn' )
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt' )
  final DateTime? lt;
  @JsonKey(name: 'lte' )
  final DateTime? lte;
  @JsonKey(name: 'gt' )
  final DateTime? gt;
  @JsonKey(name: 'gte' )
  final DateTime? gte;
  @JsonKey(name: 'not' )
  final NestedDateTimeFilter? not;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),];
}
class NestedJsonFilter implements ToField  {
  const NestedJsonFilter({
  this.equals,
  this.path,
  this.string_contains,
  this.string_starts_with,
  this.string_ends_with,
  this.array_contains,
  this.array_starts_with,
  this.array_ends_with,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final Map<String,dynamic>? equals;
  @JsonKey(name: 'path' )
  final List<String>? path;
  @JsonKey(name: 'string_contains' )
  final String? string_contains;
  @JsonKey(name: 'string_starts_with' )
  final String? string_starts_with;
  @JsonKey(name: 'string_ends_with' )
  final String? string_ends_with;
  @JsonKey(name: 'array_contains' )
  final Map<String,dynamic>? array_contains;
  @JsonKey(name: 'array_starts_with' )
  final Map<String,dynamic>? array_starts_with;
  @JsonKey(name: 'array_ends_with' )
  final Map<String,dynamic>? array_ends_with;
  @JsonKey(name: 'lt' )
  final Map<String,dynamic>? lt;
  @JsonKey(name: 'lte' )
  final Map<String,dynamic>? lte;
  @JsonKey(name: 'gt' )
  final Map<String,dynamic>? gt;
  @JsonKey(name: 'gte' )
  final Map<String,dynamic>? gte;
  @JsonKey(name: 'not' )
  final Map<String,dynamic>? not;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(path !=null)Field("path",true,false,toScalerField(path!),null,),if(string_contains !=null)Field("string_contains",false,false,string_contains!,null,),if(string_starts_with !=null)Field("string_starts_with",false,false,string_starts_with!,null,),if(string_ends_with !=null)Field("string_ends_with",false,false,string_ends_with!,null,),if(array_contains !=null)Field("array_contains",false,false,array_contains!,null,),if(array_starts_with !=null)Field("array_starts_with",false,false,array_starts_with!,null,),if(array_ends_with !=null)Field("array_ends_with",false,false,array_ends_with!,null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,not!,null,),];
}
class NestedDateTimeWithAggregatesFilter implements ToField  {
  const NestedDateTimeWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final DateTime? equals;
  @JsonKey(name: 'in' )
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn' )
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt' )
  final DateTime? lt;
  @JsonKey(name: 'lte' )
  final DateTime? lte;
  @JsonKey(name: 'gt' )
  final DateTime? gt;
  @JsonKey(name: 'gte' )
  final DateTime? gte;
  @JsonKey(name: 'not' )
  final NestedDateTimeWithAggregatesFilter? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedDateTimeFilter? $min;
  @JsonKey(name: '_max' )
  final NestedDateTimeFilter? $max;

@override
List<Field> toFields()=>[if(equals !=null)Field("equals",false,false,equals!,null,),if(in$ !=null)Field("in",true,false,toScalerField(in$!),null,),if(notIn !=null)Field("notIn",true,false,toScalerField(notIn!),null,),if(lt !=null)Field("lt",false,false,lt!,null,),if(lte !=null)Field("lte",false,false,lte!,null,),if(gt !=null)Field("gt",false,false,gt!,null,),if(gte !=null)Field("gte",false,false,gte!,null,),if(not !=null)Field("not",false,false,null,not!.toFields()
,),if($count !=null)Field("_count",false,false,null,$count!.toFields()
,),if($min !=null)Field("_min",false,false,null,$min!.toFields()
,),if($max !=null)Field("_max",false,false,null,$max!.toFields()
,),];
}



@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class AggregateUser {
  const AggregateUser({
     this.$count,
     this.$avg,
     this.$sum,
     this.$min,
     this.$max,
  });

  @JsonKey(name: '_count' )
  final UserCountAggregateOutputType? $count;
  @JsonKey(name: '_avg' )
  final UserAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum' )
  final UserSumAggregateOutputType? $sum;
  @JsonKey(name: '_min' )
  final UserMinAggregateOutputType? $min;
  @JsonKey(name: '_max' )
  final UserMaxAggregateOutputType? $max;

  factory AggregateUser.fromJson(Map<String, dynamic> json) =>
    _$AggregateUserFromJson(json);

      Map<String, dynamic> toJson() => _$AggregateUserToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class UserGroupByOutputType {
  const UserGroupByOutputType({
   required  this.id,
   required  this.email,
   required  this.name,
     this.role,
     this.$count,
     this.$avg,
     this.$sum,
     this.$min,
     this.$max,
  });

  @JsonKey(name: 'id' )
  final int id;
  @JsonKey(name: 'email' )
  final String email;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'role' )
  final List<String>? role;
  @JsonKey(name: '_count' )
  final UserCountAggregateOutputType? $count;
  @JsonKey(name: '_avg' )
  final UserAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum' )
  final UserSumAggregateOutputType? $sum;
  @JsonKey(name: '_min' )
  final UserMinAggregateOutputType? $min;
  @JsonKey(name: '_max' )
  final UserMaxAggregateOutputType? $max;

  factory UserGroupByOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserGroupByOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$UserGroupByOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class AggregateAd {
  const AggregateAd({
     this.$count,
     this.$avg,
     this.$sum,
     this.$min,
     this.$max,
  });

  @JsonKey(name: '_count' )
  final AdCountAggregateOutputType? $count;
  @JsonKey(name: '_avg' )
  final AdAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum' )
  final AdSumAggregateOutputType? $sum;
  @JsonKey(name: '_min' )
  final AdMinAggregateOutputType? $min;
  @JsonKey(name: '_max' )
  final AdMaxAggregateOutputType? $max;

  factory AggregateAd.fromJson(Map<String, dynamic> json) =>
    _$AggregateAdFromJson(json);

      Map<String, dynamic> toJson() => _$AggregateAdToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class AdGroupByOutputType {
  const AdGroupByOutputType({
   required  this.id,
   required  this.title,
   required  this.filter,
   required  this.content,
   required  this.createdAt,
   required  this.expiredAt,
     this.$count,
     this.$avg,
     this.$sum,
     this.$min,
     this.$max,
  });

  @JsonKey(name: 'id' )
  final int id;
  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'filter' )
  final Map<String,dynamic> filter;
  @JsonKey(name: 'content' )
  final Map<String,dynamic> content;
  @JsonKey(name: 'createdAt' )
  final DateTime createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTime expiredAt;
  @JsonKey(name: '_count' )
  final AdCountAggregateOutputType? $count;
  @JsonKey(name: '_avg' )
  final AdAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum' )
  final AdSumAggregateOutputType? $sum;
  @JsonKey(name: '_min' )
  final AdMinAggregateOutputType? $min;
  @JsonKey(name: '_max' )
  final AdMaxAggregateOutputType? $max;

  factory AdGroupByOutputType.fromJson(Map<String, dynamic> json) =>
    _$AdGroupByOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$AdGroupByOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class AffectedRowsOutput {
  const AffectedRowsOutput({
   required  this.count,
  });

  @JsonKey(name: 'count' )
  final int count;

  factory AffectedRowsOutput.fromJson(Map<String, dynamic> json) =>
    _$AffectedRowsOutputFromJson(json);

      Map<String, dynamic> toJson() => _$AffectedRowsOutputToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class UserCountAggregateOutputType {
  const UserCountAggregateOutputType({
   required  this.id,
   required  this.email,
   required  this.name,
   required  this.role,
   required  this.$all,
  });

  @JsonKey(name: 'id' )
  final int id;
  @JsonKey(name: 'email' )
  final int email;
  @JsonKey(name: 'name' )
  final int name;
  @JsonKey(name: 'role' )
  final int role;
  @JsonKey(name: '_all' )
  final int $all;

  factory UserCountAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserCountAggregateOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$UserCountAggregateOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class UserAvgAggregateOutputType {
  const UserAvgAggregateOutputType({
     this.id,
  });

  @JsonKey(name: 'id' )
  final double? id;

  factory UserAvgAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserAvgAggregateOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$UserAvgAggregateOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class UserSumAggregateOutputType {
  const UserSumAggregateOutputType({
     this.id,
  });

  @JsonKey(name: 'id' )
  final int? id;

  factory UserSumAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserSumAggregateOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$UserSumAggregateOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class UserMinAggregateOutputType {
  const UserMinAggregateOutputType({
     this.id,
     this.email,
     this.name,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'email' )
  final String? email;
  @JsonKey(name: 'name' )
  final String? name;

  factory UserMinAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserMinAggregateOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$UserMinAggregateOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class UserMaxAggregateOutputType {
  const UserMaxAggregateOutputType({
     this.id,
     this.email,
     this.name,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'email' )
  final String? email;
  @JsonKey(name: 'name' )
  final String? name;

  factory UserMaxAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserMaxAggregateOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$UserMaxAggregateOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class AdCountAggregateOutputType {
  const AdCountAggregateOutputType({
   required  this.id,
   required  this.title,
   required  this.filter,
   required  this.content,
   required  this.createdAt,
   required  this.expiredAt,
   required  this.$all,
  });

  @JsonKey(name: 'id' )
  final int id;
  @JsonKey(name: 'title' )
  final int title;
  @JsonKey(name: 'filter' )
  final int filter;
  @JsonKey(name: 'content' )
  final int content;
  @JsonKey(name: 'createdAt' )
  final int createdAt;
  @JsonKey(name: 'expiredAt' )
  final int expiredAt;
  @JsonKey(name: '_all' )
  final int $all;

  factory AdCountAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$AdCountAggregateOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$AdCountAggregateOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class AdAvgAggregateOutputType {
  const AdAvgAggregateOutputType({
     this.id,
  });

  @JsonKey(name: 'id' )
  final double? id;

  factory AdAvgAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$AdAvgAggregateOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$AdAvgAggregateOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class AdSumAggregateOutputType {
  const AdSumAggregateOutputType({
     this.id,
  });

  @JsonKey(name: 'id' )
  final int? id;

  factory AdSumAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$AdSumAggregateOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$AdSumAggregateOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class AdMinAggregateOutputType {
  const AdMinAggregateOutputType({
     this.id,
     this.title,
     this.createdAt,
     this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTime? expiredAt;

  factory AdMinAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$AdMinAggregateOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$AdMinAggregateOutputTypeToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class AdMaxAggregateOutputType {
  const AdMaxAggregateOutputType({
     this.id,
     this.title,
     this.createdAt,
     this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTime? expiredAt;

  factory AdMaxAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$AdMaxAggregateOutputTypeFromJson(json);

      Map<String, dynamic> toJson() => _$AdMaxAggregateOutputTypeToJson(this);

}

@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class User {
  const User({
   required  this.id,
   required  this.email,
   required  this.name,
     this.role,
  });

  @JsonKey(name: 'id' )
  final int id;
  @JsonKey(name: 'email' )
  final String email;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'role' )
  final List<String>? role;

  factory User.fromJson(Map<String, dynamic> json) =>
    _$UserFromJson(json);

      Map<String, dynamic> toJson() => _$UserToJson(this);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: true)
class Ad {
  const Ad({
   required  this.id,
   required  this.title,
   required  this.filter,
   required  this.content,
   required  this.createdAt,
   required  this.expiredAt,
  });

  @JsonKey(name: 'id' )
  final int id;
  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'filter' )
  final Map<String,dynamic> filter;
  @JsonKey(name: 'content' )
  final Map<String,dynamic> content;
  @JsonKey(name: 'createdAt' )
  final DateTime createdAt;
  @JsonKey(name: 'expiredAt' )
  final DateTime expiredAt;

  factory Ad.fromJson(Map<String, dynamic> json) =>
    _$AdFromJson(json);

      Map<String, dynamic> toJson() => _$AdToJson(this);

}



class UserModel {
  static const String model = "User";
final Engine engine;
UserModel(this.engine);
static const  _outputField = [Output("id"),Output("email"),Output("name"),Output("role")];
Future<User?> findUnique({
    required  UserWhereUniqueInput where,
}
){
final input=[Input("where",false,null,where.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "findUnique",
      operation: "query",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<User?> findFirst({
      UserWhereInput? where,
      List<UserOrderByWithRelationInput>? orderBy,
      UserWhereUniqueInput? cursor,
      int? take,
      int? skip,
      List<UserScalarFieldEnum>? distinct,
}
){
final input=[if(where !=null)Input("where",false,null,where.toFields()
,),if(orderBy !=null)Input("orderBy",true,null,toObjectField(orderBy),),if(cursor !=null)Input("cursor",false,null,cursor.toFields()
,),if(take !=null)Input("take",false,take,null,),if(skip !=null)Input("skip",false,skip,null,),if(distinct !=null)Input("distinct",true,toEnumsField(distinct),null,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "findFirst",
      operation: "query",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<List<User>> findMany({
      UserWhereInput? where,
      List<UserOrderByWithRelationInput>? orderBy,
      UserWhereUniqueInput? cursor,
      int? take,
      int? skip,
      List<UserScalarFieldEnum>? distinct,
}
){
final input=[if(where !=null)Input("where",false,null,where.toFields()
,),if(orderBy !=null)Input("orderBy",true,null,toObjectField(orderBy),),if(cursor !=null)Input("cursor",false,null,cursor.toFields()
,),if(take !=null)Input("take",false,take,null,),if(skip !=null)Input("skip",false,skip,null,),if(distinct !=null)Input("distinct",true,toEnumsField(distinct),null,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "findMany",
      operation: "query",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null) return []; return (value.data!.result! as List).map((e) {return User.fromJson(value.data!.result! as Map<String,dynamic>);} ).toList();
   }
     );     

}Future<User> createOne({
    required  UserCreateInput data,
}
){
final input=[Input("data",false,null,data.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "createOne",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AffectedRowsOutput> createMany({
    required  List<UserCreateManyInput> data,
      bool? skipDuplicates,
}
){
final input=[Input("data",true,null,toObjectField(data),),if(skipDuplicates !=null)Input("skipDuplicates",false,skipDuplicates,null,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "createMany",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<User?> updateOne({
    required  UserUpdateInput data,
    required  UserWhereUniqueInput where,
}
){
final input=[Input("data",false,null,data.toFields()
,),Input("where",false,null,where.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "updateOne",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AffectedRowsOutput> updateMany({
    required  UserUpdateManyMutationInput data,
      UserWhereInput? where,
}
){
final input=[Input("data",false,null,data.toFields()
,),if(where !=null)Input("where",false,null,where.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "updateMany",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<User> upsertOne({
    required  UserWhereUniqueInput where,
    required  UserCreateInput create,
    required  UserUpdateInput update,
}
){
final input=[Input("where",false,null,where.toFields()
,),Input("create",false,null,create.toFields()
,),Input("update",false,null,update.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "upsertOne",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<User?> deleteOne({
    required  UserWhereUniqueInput where,
}
){
final input=[Input("where",false,null,where.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "deleteOne",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AffectedRowsOutput> deleteMany({
      UserWhereInput? where,
}
){
final input=[if(where !=null)Input("where",false,null,where.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "deleteMany",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AggregateUser> aggregate({
      UserWhereInput? where,
      List<UserOrderByWithRelationInput>? orderBy,
      UserWhereUniqueInput? cursor,
      int? take,
      int? skip,
}
){
final input=[if(where !=null)Input("where",false,null,where.toFields()
,),if(orderBy !=null)Input("orderBy",true,null,toObjectField(orderBy),),if(cursor !=null)Input("cursor",false,null,cursor.toFields()
,),if(take !=null)Input("take",false,take,null,),if(skip !=null)Input("skip",false,skip,null,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "aggregate",
      operation: "query",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AggregateUser.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<List<UserGroupByOutputType>> groupBy({
      UserWhereInput? where,
      List<UserOrderByWithAggregationInput>? orderBy,
    required  List<UserScalarFieldEnum> by,
      UserScalarWhereWithAggregatesInput? having,
      int? take,
      int? skip,
}
){
final input=[if(where !=null)Input("where",false,null,where.toFields()
,),if(orderBy !=null)Input("orderBy",true,null,toObjectField(orderBy),),Input("by",true,toEnumsField(by),null,),if(having !=null)Input("having",false,null,having.toFields()
,),if(take !=null)Input("take",false,take,null,),if(skip !=null)Input("skip",false,skip,null,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "groupBy",
      operation: "query",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null) return []; return (value.data!.result! as List).map((e) {return UserGroupByOutputType.fromJson(value.data!.result! as Map<String,dynamic>);} ).toList();
   }
     );     

}
}
class AdModel {
  static const String model = "Ad";
final Engine engine;
AdModel(this.engine);
static const  _outputField = [Output("id"),Output("title"),Output("filter"),Output("content"),Output("createdAt"),Output("expiredAt")];
Future<Ad?> findUnique({
    required  AdWhereUniqueInput where,
}
){
final input=[Input("where",false,null,where.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "findUnique",
      operation: "query",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return Ad.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<Ad?> findFirst({
      AdWhereInput? where,
      List<AdOrderByWithRelationInput>? orderBy,
      AdWhereUniqueInput? cursor,
      int? take,
      int? skip,
      List<AdScalarFieldEnum>? distinct,
}
){
final input=[if(where !=null)Input("where",false,null,where.toFields()
,),if(orderBy !=null)Input("orderBy",true,null,toObjectField(orderBy),),if(cursor !=null)Input("cursor",false,null,cursor.toFields()
,),if(take !=null)Input("take",false,take,null,),if(skip !=null)Input("skip",false,skip,null,),if(distinct !=null)Input("distinct",true,toEnumsField(distinct),null,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "findFirst",
      operation: "query",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return Ad.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<List<Ad>> findMany({
      AdWhereInput? where,
      List<AdOrderByWithRelationInput>? orderBy,
      AdWhereUniqueInput? cursor,
      int? take,
      int? skip,
      List<AdScalarFieldEnum>? distinct,
}
){
final input=[if(where !=null)Input("where",false,null,where.toFields()
,),if(orderBy !=null)Input("orderBy",true,null,toObjectField(orderBy),),if(cursor !=null)Input("cursor",false,null,cursor.toFields()
,),if(take !=null)Input("take",false,take,null,),if(skip !=null)Input("skip",false,skip,null,),if(distinct !=null)Input("distinct",true,toEnumsField(distinct),null,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "findMany",
      operation: "query",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null) return []; return (value.data!.result! as List).map((e) {return Ad.fromJson(value.data!.result! as Map<String,dynamic>);} ).toList();
   }
     );     

}Future<Ad> createOne({
    required  AdCreateInput data,
}
){
final input=[Input("data",false,null,data.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "createOne",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return Ad.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AffectedRowsOutput> createMany({
    required  List<AdCreateManyInput> data,
      bool? skipDuplicates,
}
){
final input=[Input("data",true,null,toObjectField(data),),if(skipDuplicates !=null)Input("skipDuplicates",false,skipDuplicates,null,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "createMany",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<Ad?> updateOne({
    required  AdUpdateInput data,
    required  AdWhereUniqueInput where,
}
){
final input=[Input("data",false,null,data.toFields()
,),Input("where",false,null,where.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "updateOne",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return Ad.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AffectedRowsOutput> updateMany({
    required  AdUpdateManyMutationInput data,
      AdWhereInput? where,
}
){
final input=[Input("data",false,null,data.toFields()
,),if(where !=null)Input("where",false,null,where.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "updateMany",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<Ad> upsertOne({
    required  AdWhereUniqueInput where,
    required  AdCreateInput create,
    required  AdUpdateInput update,
}
){
final input=[Input("where",false,null,where.toFields()
,),Input("create",false,null,create.toFields()
,),Input("update",false,null,update.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "upsertOne",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return Ad.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<Ad?> deleteOne({
    required  AdWhereUniqueInput where,
}
){
final input=[Input("where",false,null,where.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "deleteOne",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return Ad.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AffectedRowsOutput> deleteMany({
      AdWhereInput? where,
}
){
final input=[if(where !=null)Input("where",false,null,where.toFields()
,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "deleteMany",
      operation: "mutation",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AggregateAd> aggregate({
      AdWhereInput? where,
      List<AdOrderByWithRelationInput>? orderBy,
      AdWhereUniqueInput? cursor,
      int? take,
      int? skip,
}
){
final input=[if(where !=null)Input("where",false,null,where.toFields()
,),if(orderBy !=null)Input("orderBy",true,null,toObjectField(orderBy),),if(cursor !=null)Input("cursor",false,null,cursor.toFields()
,),if(take !=null)Input("take",false,take,null,),if(skip !=null)Input("skip",false,skip,null,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "aggregate",
      operation: "query",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AggregateAd.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<List<AdGroupByOutputType>> groupBy({
      AdWhereInput? where,
      List<AdOrderByWithAggregationInput>? orderBy,
    required  List<AdScalarFieldEnum> by,
      AdScalarWhereWithAggregatesInput? having,
      int? take,
      int? skip,
}
){
final input=[if(where !=null)Input("where",false,null,where.toFields()
,),if(orderBy !=null)Input("orderBy",true,null,toObjectField(orderBy),),Input("by",true,toEnumsField(by),null,),if(having !=null)Input("having",false,null,having.toFields()
,),if(take !=null)Input("take",false,take,null,),if(skip !=null)Input("skip",false,skip,null,),];
    final query = Query(
      engine: engine,
      model: model,
      method: "groupBy",
      operation: "query",
      input:input,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null) return []; return (value.data!.result! as List).map((e) {return AdGroupByOutputType.fromJson(value.data!.result! as Map<String,dynamic>);} ).toList();
   }
     );     

}
}
const schema='''// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-dart"
  output   = "lib/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id    Int      @id @default(autoincrement())
  email String   @unique
  name  String
  role  String[]
}

model Ad {
  id        Int      @id @default(autoincrement())
  title     String
  filter    Json
  content   Json
  createdAt DateTime @default(now())
  expiredAt DateTime
}
''';
